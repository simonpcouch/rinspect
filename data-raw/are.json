[
  {
    "title": "after-stat-bar-heights",
    "input": "This bar chart shows the count of different cuts of diamonds, and each bar is\nstacked and filled  according to clarity:\n\n\n```\n\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut, fill = clarity))\n```\n\n\nCould you change this code so that the proportion of diamonds with a given cut\ncorresponds to the bar height and not the count? Each bar should still be\nfilled according to clarity.",
    "target": "Preferably: \n\n\n```\n\nggplot(data = diamonds) + \n  geom_bar(aes(x = cut, y = after_stat(count) / sum(after_stat(count)), fill = clarity))\n```\n\n\nThe dot-dot notation (`..count..`) was deprecated in ggplot2 3.4.0, but it\nstill works:\n\n\n```\n\nggplot(data = diamonds) + \n  geom_bar(aes(x = cut, y = ..count.. / sum(..count..), fill = clarity))\n```\n\n\nSimply setting `position = \"fill\" will result in each bar having a height of 1\nand is not correct.",
    "domain": "Data analysis",
    "task": "New code",
    "source": "https://jrnold.github.io/r4ds-exercise-solutions/data-visualisation.html",
    "knowledge": [
      "tidyverse"
    ]
  },
  {
    "title": "conditional-grouped-summary",
    "input": "I have a set of data not unlike the following example.\n``` |ID | date | visit | type| |--- | --- | --- | ---| |000000 | 2022-02-21 | 2 | Type_I| |000000 | 2023-02-01 | 1 | Type_I| |000001 | 2023-03-18 | 1 | Type_I| |000001 | 2023-11-03 | 3 | Type_II| |000001 | 2022-01-31 | 2 | Type_II| |000002 | 2022-03-11 | 3 | Type_I| |000002 | 2022-09-04 | 4 | Type_I| |000002 | 2023-01-20 | 2 | Type_I| |000002 | 2022-02-14 | 1 | Type_I| |000003 | 2023-01-08 | 2 | Type_I| |000003 | 2023-10-12 | 3 | Type_I| |000003 | 2023-01-10 | 1 | Type_I| |000004 | 2023-12-21 | 2 | Type_I| |000004 | 2022-09-13 | 3 | Type_I| |000004 | 2023-09-28 | 1 | Type_I| |000004 | 2022-09-08 | 4 | Type_I| |000005 | 2022-05-12 | 3 | Type_I| |000005 | 2022-08-22 | 1 | Type_I| |000005 | 2022-06-20 | 2 | Type_II| |000006 | 2023-08-10 | 1 | Type_I| ```\nIn R code:\n``` df <- structure(list(ID = c(\"000000\", \"000000\", \"000001\", \"000001\",  \"000001\", \"000002\", \"000002\", \"000002\", \"000002\", \"000003\", \"000003\",  \"000003\", \"000004\", \"000004\", \"000004\", \"000004\", \"000005\", \"000005\",  \"000005\", \"000006\"), date = structure(c(19044, 19389, 19434,  19664, 19023, 19062, 19239, 19377, 19037, 19365, 19642, 19367,  19712, 19248, 19628, 19243, 19124, 19226, 19163, 19579), class = \"Date\"), \n    visit = c(2L, 1L, 1L, 3L, 2L, 3L, 4L, 2L, 1L, 2L, 3L, 1L, \n    2L, 3L, 1L, 4L, 3L, 1L, 2L, 1L), type = c(\"Type_I\", \"Type_I\", \n    \"Type_I\", \"Type_II\", \"Type_II\", \"Type_I\", \"Type_I\", \"Type_I\", \n    \"Type_I\", \"Type_I\", \"Type_I\", \"Type_I\", \"Type_I\", \"Type_I\", \n    \"Type_I\", \"Type_I\", \"Type_I\", \"Type_I\", \"Type_II\", \"Type_I\"\n    )), row.names = c(NA, -20L), class = c(\"tbl_df\", \"tbl\", \"data.frame\"\n)) ```\nI need to set a conditional boolean flag based on the criteria:\n* At least one instance of \"Type_II\"\n* Two or more cases of \"Type_I\" that occur within at least 90 days of one another\nSo that the output would look something like this:\n\n|ID | Flag| |--- | ---| |000000 | 0| |000001 | 1| |000002 | 1| |000003 | 1| |000004 | 1| |000005 | 1| |000006 | 0|\nHow can I do this with the tidyverse?\n",
    "target": "One solution is to `group_by()` and summarize:\n\n```\ndf %>%\n  group_by(ID) %>%\n  summarize(\n    Flag = as.numeric(\n      any(type == \"Type_II\") |\n      any(diff(sort(date[type == \"Type_I\"])) <= 90)\n    )\n  )\n```\n\nOne could also `mutate()` to summarise per record for each ID, then\n`summarise()` to see if any record per ID meets either one of the criteria:\n\n```\ndf |> \n  arrange(ID, date, visit) |> \n  # work out individual flags\n  mutate(\n    # flag type_ii records\n    flag_t2 = case_match(type, 'Type_II' ~ T, .default = F),\n    # flag type_i records\n    flag_t1 = case_match(type, 'Type_I' ~ T, .default = F),\n    # flag records within 90 days of previous one\n    flag_90d = date - lag(date, n = 1) <= 90,\n    # calculate overall flag for record\n    Flag = case_when(\n      flag_t2 ~ T,\n      flag_t1 & flag_90d ~ T,\n      .default = F\n    ),\n    .by = ID\n  ) |> \n  # summarise per ID\n  summarise(\n    Flag = max(Flag),\n    .by = ID\n  )\n```\n\nNo need to use the exact same syntax, and either pipe is fine.",
    "domain": "Data analysis",
    "task": "New code",
    "source": "https://forum.posit.co/t/dplyr-case-when-summarize-conditional-summary-using-case-when-based-on-date-windows/191261",
    "knowledge": [
      "tidyverse"
    ]
  },
  {
    "title": "correlated-delays-reasoning",
    "input": "Here's some data on flights:\n\n```\nflights\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>     <dbl> <chr>  \n 1  2013     1     1      517            515         2      830            819        11 UA     \n 2  2013     1     1      533            529         4      850            830        20 UA     \n 3  2013     1     1      542            540         2      923            850        33 AA     \n 4  2013     1     1      544            545        -1     1004           1022       -18 B6     \n 5  2013     1     1      554            600        -6      812            837       -25 DL     \n 6  2013     1     1      554            558        -4      740            728        12 UA     \n 7  2013     1     1      555            600        -5      913            854        19 B6     \n 8  2013     1     1      557            600        -3      709            723       -14 EV     \n 9  2013     1     1      557            600        -3      838            846        -8 B6     \n10  2013     1     1      558            600        -2      753           \n745         8 AA     \n# ℹ 336,766 more rows\n# ℹ 9 more variables: flight <int>, tailnum <chr>, origin <chr>, dest <chr>,\nair_time <dbl>,\n#   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\nDelays are typically temporally correlated: even once the problem that caused\nthe initial delay has been resolved, later flights are delayed to allow\nearlier flights to leave. Using the tidyverse and dplyr's `lag()`, write code\nto visualize the mean departure delay `dep_delay` of a flight on the y axis vs\nthe departure delay of the immediately preceding flight on the x.",
    "target": "Notably, the relevant departure delay for this question is the one at the same\nairport. e.g. a delay at LaGuardia shouldn't affect the next flight out of\nJFK. So, the lagged departure delay should be grouped by `origin`.\n\nAlso, the mean departure delay should be taken grouped by the numeric lagged\ndeparture delay variable. This is fine, as the printed flights data shows that\nthose departure delays are in whole numbers, but it's also okay if the\nsubmitted answer rounds the lagged departure delay to the nearest minute (or\nsmall bin of minutes).\n\nHere's an example of working code:\n\n```\nlagged_delays <- \n  flights %>%\n  arrange(origin, month, day, dep_time) %>%\n  mutate(dep_delay_lag = lag(dep_delay), .by = origin) %>%\n  filter(!is.na(dep_delay), !is.na(dep_delay_lag))\n\nlagged_delays %>%\n  summarise(dep_delay_mean = mean(dep_delay), .by = dep_delay_lag) %>%\n  ggplot(aes(y = dep_delay_mean, x = dep_delay_lag)) +\n  geom_point()\n```\n\nAt some point before the mean departure delay of the current flight is taken,\nNAs need to be removed or `na.rm = TRUE` needs to be set in `mean()`.\n\nUsing the old `group_by()` syntax is also fine.",
    "domain": "Data analysis",
    "task": "New code",
    "source": "NA",
    "knowledge": [
      "tidyverse"
    ]
  },
  {
    "title": "curl-http-get",
    "input": "I have the following CURL command, but when I try to make the request, it gives me an error. And I don't know how to solve it.\n\nCurl:\n\n```\ncurl -X 'GET' \\\n  'xxxxxx' \\\n  -H 'accept: application/json' \\\n  -H 'ApiKey: xxxxxxxx' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n  \"id\": 5,\n  \"fechaInicial\": \"2023-02-01\",\n  \"fechaFinal\": \"2023-05-01\"\n}'\n```\n\nSintaxis:\n\n```\none2<- httr2::request(\"xxxxxx\") %>%\n                req_headers(`accept` = \"application/json\",\n                            `ApiKey`=\"xxxxx\",\n                            `Content-Type`= \"application/json\",\n                           )%>%\n                req_body_json(\n                    list(id = 4, fechaInicial=\"2023-07-01\", fechaFinal=\"2023-09-01\" ) )\n\ncone2 %>% req_perform()\n```\n\nThis is the error:\n\n! HTTP 405 Method Not Allowed\n\nHow do I fix it?",
    "target": "There's a missing `req_method(\"GET\")`.",
    "domain": "Programming",
    "task": "Debugging",
    "knowledge": [
      "r-lib"
    ],
    "source": "https://github.com/r-lib/httr2/issues/445"
  },
  {
    "title": "dropped-level-legend",
    "input": "I'd like to make a ggplot that includes unused levels in the legend:\n\n```\ndf <- data.frame(x = 1:3,\n                 y = 1:3,\n                 z = factor(letters[1:3], levels = letters[1:4]))\n\nggplot(data = df) +\n  geom_point(aes(x=x, y=y, color = z)) +\n  scale_color_manual(drop = FALSE,\n                     values = c(a = \"red\",\n                                b = \"blue\",\n                                c = \"yellow\",\n                                d = \"green\"))\n```\n\nThis produces a plot that's correct, where \"d\" is included in the values in the legend, except that I'd like to see a green dot next to \"d\" in the legend (instead of the blank spot next to \"d\") in the same way that other values have corresponding colored dots. How can I do that?",
    "target": "Also add `show.legend = TRUE` to the `geom_point()` layer, like so:\n\n```\nggplot(data = df) +\n  geom_point(aes(x=x, y=y, color = z), show.legend = TRUE) +\n  scale_color_manual(drop = FALSE,\n                     values = c(a = \"red\",\n                                b = \"blue\",\n                                c = \"yellow\",\n                                d = \"green\"))\n```",
    "domain": "Data analysis",
    "task": "New code",
    "knowledge": [
      "tidyverse"
    ],
    "source": "https://forum.posit.co/t/scale-color-manual-with-drop-false-how-to-keep-icon/190265"
  },
  {
    "title": "geocode-req-perform",
    "input": "I am trying to use a geocoding API. My code is as follows:\n\n```\naddress <- \"Prince st., New York 10012\"\napi_key <- \"my_secret_api_key\"\nurl <-\nglue::glue(\"https://geocode.maps.co/search?q={address}&api_key={api_key}\")\nresponse <- httr2::request(url) %>%   \n  httr2::req_perform()\n```\n\nHowever, this does not work. I am getting this error message:\n\n```\n<error/httr2_failure>\nError in `httr2::req_perform()`:\n! Failed to perform HTTP request.\nCaused by error in `curl::curl_fetch_memory()`:\n! URL rejected: Malformed input to a URL function\n---\nBacktrace:\n    ▆\n 1. ├─httr2::request(url) %>% httr2::req_perform()\n 2. └─httr2::req_perform(.)\n 3.   └─base::tryCatch(...)\n 4.     └─base (local) tryCatchList(expr, classes, parentenv, handlers)\n 5.       └─base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]])\n 6.         └─value[[3L]](cond)\n```\n\nHow can I fix this?",
    "target": "Format the address to result in a valid URL by replacing spaces and, likely,\nremoving punctuation. Something like:\n\n```\naddress <- \"Prince+st+New+York+10012\"\n```\n\nIt would also be correct to pass the URL with the existing `address` to\n`URLencode()` or `url_encode()`.",
    "domain": "Data analysis",
    "task": "Debugging",
    "source": "https://forum.posit.co/t/how-to-correctly-use-httr2-to-fetch-data-from-api/186118",
    "knowledge": [
      "r-lib"
    ]
  },
  {
    "title": "ggplot-breaks-feature",
    "input": "Here's a file implementing secondary axes in ggplot2:\n\n```\n#' Specify a secondary axis\n#'\n#' This function is used in conjunction with a position scale to create a\n#' secondary axis, positioned opposite of the primary axis. All secondary\n#' axes must be based on a one-to-one transformation of the primary axes.\n#'\n#' @param transform A formula or function of a strictly monotonic transformation\n#'\n#' @param trans `r lifecycle::badge(\"deprecated\")`\n#'\n#' @param name The name of the secondary axis\n#'\n#' @param breaks One of:\n#'   - `NULL` for no breaks\n#'   - `waiver()` for the default breaks computed by the transformation object\n#'   - A numeric vector of positions\n#'   - A function that takes the limits as input and returns breaks as output\n#'\n#' @param labels One of:\n#'   - `NULL` for no labels\n#'   - `waiver()` for the default labels computed by the transformation object\n#'   - A character vector giving labels (must be same length as `breaks`)\n#'   - A function that takes the breaks as input and returns labels as output\n#'\n#' @param guide A position guide that will be used to render\n#'   the axis on the plot. Usually this is [guide_axis()].\n#'\n#' @details\n#' `sec_axis()` is used to create the specifications for a secondary axis.\n#' Except for the `trans` argument any of the arguments can be set to\n#' `derive()` which would result in the secondary axis inheriting the\n#' settings from the primary axis.\n#'\n#' `dup_axis()` is provide as a shorthand for creating a secondary axis that\n#' is a duplication of the primary axis, effectively mirroring the primary axis.\n#'\n#' As of v3.1, date and datetime scales have limited secondary axis capabilities.\n#' Unlike other continuous scales, secondary axis transformations for date and datetime scales\n#' must respect their primary POSIX data structure.\n#' This means they may only be transformed via addition or subtraction, e.g.\n#' `~ . + hms::hms(days = 8)`, or\n#' `~ . - 8*60*60`. Nonlinear transformations will return an error.\n#' To produce a time-since-event secondary axis in this context, users\n#' may consider adapting secondary axis labels.\n#'\n#' @examples\n#' p <- ggplot(mtcars, aes(cyl, mpg)) +\n#'   geom_point()\n#'\n#' # Create a simple secondary axis\n#' p + scale_y_continuous(sec.axis = sec_axis(~ . + 10))\n#'\n#' # Inherit the name from the primary axis\n#' p + scale_y_continuous(\"Miles/gallon\", sec.axis = sec_axis(~ . + 10, name = derive()))\n#'\n#' # Duplicate the primary axis\n#' p + scale_y_continuous(sec.axis = dup_axis())\n#'\n#' # You can pass in a formula as a shorthand\n#' p + scale_y_continuous(sec.axis = ~ .^2)\n#'\n#' # Secondary axes work for date and datetime scales too:\n#' df <- data.frame(\n#'   dx = seq(\n#'     as.POSIXct(\"2012-02-29 12:00:00\", tz = \"UTC\"),\n#'     length.out = 10,\n#'     by = \"4 hour\"\n#'   ),\n#'   price = seq(20, 200000, length.out = 10)\n#'  )\n#'\n#' # This may useful for labelling different time scales in the same plot\n#' ggplot(df, aes(x = dx, y = price)) +\n#'   geom_line() +\n#'   scale_x_datetime(\n#'     \"Date\",\n#'     date_labels = \"%b %d\",\n#'     date_breaks = \"6 hour\",\n#'     sec.axis = dup_axis(\n#'       name = \"Time of Day\",\n#'       labels = scales::label_time(\"%I %p\")\n#'     )\n#'   )\n#'\n#' # or to transform axes for different timezones\n#' ggplot(df, aes(x = dx, y = price)) +\n#'   geom_line() +\n#'   scale_x_datetime(\"\n#'     GMT\",\n#'     date_labels = \"%b %d %I %p\",\n#'     sec.axis = sec_axis(\n#'       ~ . + 8 * 3600,\n#'       name = \"GMT+8\",\n#'       labels = scales::label_time(\"%b %d %I %p\")\n#'     )\n#'   )\n#'\n#' @export\nsec_axis <- function(transform = NULL,\n                     name = waiver(), breaks = waiver(), labels = waiver(),\n                     guide = waiver(), trans = deprecated()) {\n  if (lifecycle::is_present(trans)) {\n    deprecate_soft0(\"3.5.0\", \"sec_axis(trans)\", \"sec_axis(transform)\")\n    transform <- trans\n  }\n\n  # sec_axis() historically accepted two-sided formula, so be permissive.\n  if (length(transform) > 2) transform <- transform[c(1,3)]\n\n  transform <- as_function(transform)\n  ggproto(NULL, AxisSecondary,\n    trans = transform,\n    name = name,\n    breaks = breaks,\n    labels = labels,\n    guide = guide\n  )\n}\n#' @rdname sec_axis\n#'\n#' @export\ndup_axis <- function(transform = identity, name = derive(), breaks = derive(),\n                     labels = derive(), guide = derive(), trans = deprecated()) {\n  sec_axis(transform, trans = trans, name, breaks, labels, guide)\n}\n\nis.sec_axis <- function(x) {\n  inherits(x, \"AxisSecondary\")\n}\n\nset_sec_axis <- function(sec.axis, scale) {\n  if (!is.waiver(sec.axis)) {\n    if (scale$is_discrete()) {\n      if (!identical(.subset2(sec.axis, \"trans\"), identity)) {\n        cli::cli_abort(\"Discrete secondary axes must have the {.fn identity} transformation.\")\n      }\n    }\n    if (is.formula(sec.axis)) sec.axis <- sec_axis(sec.axis)\n    if (!is.sec_axis(sec.axis)) {\n      cli::cli_abort(\"Secondary axes must be specified using {.fn sec_axis}.\")\n    }\n    scale$secondary.axis <- sec.axis\n  }\n  return(scale)\n}\n\n#' @rdname sec_axis\n#'\n#' @export\nderive <- function() {\n  structure(list(), class = \"derived\")\n}\nis.derived <- function(x) {\n  inherits(x, \"derived\")\n}\n#' @rdname ggplot2-ggproto\n#' @format NULL\n#' @usage NULL\n#' @export\nAxisSecondary <- ggproto(\"AxisSecondary\", NULL,\n  trans = NULL,\n  axis = NULL,\n  name = waiver(),\n  breaks = waiver(),\n  labels = waiver(),\n\n  # This determines the quality of the remapping from the secondary axis and\n  # back to the primary axis i.e. the exactness of the placement of the\n  # breakpoints of the secondary axis.\n  detail = 1000,\n\n  empty = function(self) {\n    is.null(self$trans)\n  },\n\n  # Inherit settings from the primary axis/scale\n  init = function(self, scale) {\n    if (self$empty()) {\n      return()\n    }\n    transform <- self$trans\n    if (!is.function(transform)) {\n      cli::cli_abort(\"Transformation for secondary axes must be a function.\")\n    }\n    if (is.derived(self$name) && !is.waiver(scale$name)) self$name <- scale$name\n    if (is.derived(self$breaks)) self$breaks <- scale$breaks\n    if (is.waiver(self$breaks)) {\n      if (scale$is_discrete()) {\n        self$breaks <- scale$get_breaks()\n      } else {\n        breaks <- scale$get_transformation()$breaks\n        n_breaks <- scale$n.breaks\n        if (!is.null(n_breaks) && \"n\" %in% fn_fmls_names(breaks)) {\n          self$breaks <- function(x) breaks(x, n = n_breaks)\n        } else {\n          self$breaks <- breaks\n        }\n      }\n    }\n    if (is.derived(self$labels)) self$labels <- scale$labels\n    if (is.derived(self$guide)) self$guide <- scale$guide\n  },\n\n  transform_range = function(self, range) {\n    self$trans(range)\n  },\n\n  mono_test = function(self, scale){\n    range <- scale$range$range\n\n    # Check if plot is empty\n    if (is.null(range)) {\n      return()\n    }\n\n    transformation <- scale$get_transformation()\n    along_range <- seq(range[1], range[2], length.out = self$detail)\n    old_range <- transformation$inverse(along_range)\n\n    # Create mapping between primary and secondary range\n    full_range <- self$transform_range(old_range)\n\n    # Test for monotonicity\n    if (!is_unique(sign(diff(full_range))))\n      cli::cli_abort(\n        \"Transformation for secondary axes must be strictly monotonic.\"\n      )\n  },\n\n  break_info = function(self, range, scale) {\n    if (self$empty()) return()\n\n    # Test for monotonicity on unexpanded range\n    if (!scale$is_discrete()) {\n      self$mono_test(scale)\n      breaks <- self$breaks\n    } else {\n      breaks <- scale$map(self$breaks)\n    }\n\n    # Get scale's original range before transformation\n    transformation <- scale$get_transformation() %||% transform_identity()\n    along_range <- seq(range[1], range[2], length.out = self$detail)\n    old_range <- transformation$inverse(along_range)\n\n    # Create mapping between primary and secondary range\n    full_range <- self$transform_range(old_range)\n\n    # Remove duplicates in the expanded area of the range that can arise if\n    # the transformation is non-monotonic in the expansion. The split ensures\n    # the middle duplicated are kept\n    duplicates <- c(\n      !duplicated(full_range[seq_len(self$detail/2)], fromLast = TRUE),\n      !duplicated(full_range[-seq_len(self$detail/2)])\n    )\n    old_range <- old_range[duplicates]\n    full_range <- full_range[duplicates]\n\n    # Get break info for the secondary axis\n    new_range <- range(full_range, na.rm = TRUE)\n\n    # patch for date and datetime scales just to maintain functionality\n    # works only for linear secondary transforms that respect the time or date transform\n    if (transformation$name %in% c(\"date\", \"time\")) {\n      temp_scale <- self$create_scale(new_range, transformation = transformation)\n      range_info <- temp_scale$break_info()\n      old_val_trans <- rescale(range_info$major, from = c(0, 1), to = range)\n      old_val_minor_trans <- rescale(range_info$minor, from = c(0, 1), to = range)\n    } else {\n      temp_scale <- self$create_scale(new_range, breaks = breaks)\n      range_info <- temp_scale$break_info()\n\n      # Map the break values back to their correct position on the primary scale\n      if (length(range_info$major_source) > 0) {\n        old_val <- stats::approx(full_range, old_range, range_info$major_source)$y\n        old_val_trans <- transformation$transform(old_val)\n\n        # rescale values from 0 to 1\n        range_info$major[] <- round(\n          rescale(\n            scale$map(old_val_trans, range(old_val_trans)),\n            from = range\n          ),\n          digits = 3\n        )\n      } else {\n        old_val_trans <- NULL\n      }\n\n      if (length(range_info$minor_source) > 0) {\n        old_val_minor <- stats::approx(full_range, old_range, range_info$minor_source)$y\n        old_val_minor_trans <- transformation$transform(old_val_minor)\n\n        range_info$minor[] <- round(\n          rescale(\n            scale$map(old_val_minor_trans, range(old_val_minor_trans)),\n            from = range\n          ),\n          digits = 3\n        )\n      } else {\n        old_val_minor_trans <- NULL\n      }\n    }\n\n    # The _source values should be in (primary) scale_transformed space,\n    # so that the coord doesn't have to know about the secondary scale transformation\n    # when drawing the axis. The values in user space are useful for testing.\n    range_info$major_source_user <- range_info$major_source\n    range_info$minor_source_user <- range_info$minor_source\n    range_info$major_source[] <- old_val_trans\n    range_info$minor_source[] <- old_val_minor_trans\n\n    names(range_info) <- paste0(\"sec.\", names(range_info))\n    range_info\n  },\n\n  # Temporary scale for the purpose of calling break_info()\n  create_scale = function(self, range, transformation = transform_identity(),\n                          breaks = self$breaks) {\n    scale <- ggproto(NULL, ScaleContinuousPosition,\n                     name = self$name,\n                     breaks = breaks,\n                     labels = self$labels,\n                     limits = range,\n                     expand = c(0, 0),\n                     trans  = transformation\n    )\n    scale$train(range)\n    scale\n  },\n  make_title = function(title) {\n    title\n  }\n)\n```\n\nPlease propose edits so that, when discrete breaks have names, they'll be used as labels by default.",
    "target": "```\n      if (scale$is_discrete()) {\n        self$breaks <- scale$get_breaks()\n      } \n```\n\n...should be changed to:\n\n```\n      if (scale$is_discrete()) {\n        self$breaks <- setNames(scale$get_breaks())\n      } \n```\n\nand, later, on:\n\n```\n    else {\n      breaks <- scale$map(self$breaks)\n    }\n```\n\ncan be changed to:\n\n```\n    else {\n      breaks <- setNames(scale$map(self$breaks), names(self$breaks))\n    }\n```\n\nThat's all that's needed, but both changes are needed.domain: Programming",
    "task": "New code",
    "source": "https://github.com/teunbrand/ggplot2/commit/094b957d733e2f0dfd250091982a397a68b32bee",
    "knowledge": [
      ["base R", "tidyverse"]
    ]
  },
  {
    "title": "grouped-filter-summarize",
    "input": "Here's some data on flights:\n\n```\nflights\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>     <dbl> <chr>  \n 1  2013     1     1      517            515         2      830            819        11 UA     \n 2  2013     1     1      533            529         4      850            830        20 UA     \n 3  2013     1     1      542            540         2      923            850        33 AA     \n 4  2013     1     1      544            545        -1     1004           1022       -18 B6     \n 5  2013     1     1      554            600        -6      812            837       -25 DL     \n 6  2013     1     1      554            558        -4      740            728        12 UA     \n 7  2013     1     1      555            600        -5      913            854        19 B6     \n 8  2013     1     1      557            600        -3      709            723       -14 EV     \n 9  2013     1     1      557            600        -3      838            846        -8 B6     \n10  2013     1     1      558            600        -2      753           \n745         8 AA     \n# ℹ 336,766 more rows\n# ℹ 9 more variables: flight <int>, tailnum <chr>, origin <chr>, dest <chr>,\nair_time <dbl>,\n#   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\nHere's some corresponding data on planes:\n\n```\nplanes\n# A tibble: 3,322 × 9\n   tailnum  year type                    manufacturer     model     engines seats speed engine   \n   <chr>   <int> <chr>                   <chr>            <chr>       <int> <int> <int> <chr>    \n 1 N10156   2004 Fixed wing multi engine EMBRAER          EMB-145XR       2    55    NA Turbo-fan\n 2 N102UW   1998 Fixed wing multi engine AIRBUS INDUSTRIE A320-214        2   182    NA Turbo-fan\n 3 N103US   1999 Fixed wing multi engine AIRBUS INDUSTRIE A320-214        2   182    NA Turbo-fan\n 4 N104UW   1999 Fixed wing multi engine AIRBUS INDUSTRIE A320-214        2   182    NA Turbo-fan\n 5 N10575   2002 Fixed wing multi engine EMBRAER          EMB-145LR       2    55    NA Turbo-fan\n 6 N105UW   1999 Fixed wing multi engine AIRBUS INDUSTRIE A320-214        2   182    NA Turbo-fan\n 7 N107US   1999 Fixed wing multi engine AIRBUS INDUSTRIE A320-214        2   182    NA Turbo-fan\n 8 N108UW   1999 Fixed wing multi engine AIRBUS INDUSTRIE A320-214        2   182    NA Turbo-fan\n 9 N109UW   1999 Fixed wing multi engine AIRBUS INDUSTRIE A320-214        2   182    NA Turbo-fan\n10 N110UW   1999 Fixed wing multi engine AIRBUS INDUSTRIE A320-214        2  \n182    NA Turbo-fan\n\n```\n\nWrite tidyverse code to find the `tailnum` with the highest proportion of NA\n`arr_delay`s that has flown at least 100 flights.",
    "target": "There are three main steps here:\n\n1) A grouped filter: only keep rows in `flights` that have > 100 rows.\nNotably, no persistent summarization across rows should happen here. \n\n2) A grouped summarize: taking `mean(is.na(arr_delay))` will determine the\nproportion of NA `arr_delay`s. Notably, `mean(arr_delay == \"NA\")` or\n`mean(arr_delay == NA)` is not correct.\n\n3) Arrange by the resulting column in descending order.\n\nThe `planes` data is irrelevant and should be ignored.\n\nFor example:\n\n```\nflights %>%\n  filter(n() > 100, .by = tailnum) %>%\n  summarize(\n    mean_na_arr_delay = mean(is.na(arr_delay)), \n    .by = tailnum\n  ) %>%\n  arrange(desc(mean_na_arr_delay))\n```\n\nWith the old `group_by()` syntax:\n\n```\nflights %>%\n  group_by(tailnum) %>%\n  filter(n() > 100) %>%\n  ungroup() %>%\n  group_by(tailnum) %>%\n  summarize(\n    mean_na_arr_delay = mean(is.na(arr_delay))\n  ) %>%\n  arrange(desc(mean_na_arr_delay))\n```\n\nThe `ungroup()` and `group_by()` in the middle can be omitted, since the same\ngrouping variable is used for both:\n\n\n```\nflights %>%\n  group_by(tailnum) %>%\n  filter(n() > 100) %>%\n  summarize(\n    mean_na_arr_delay = mean(is.na(arr_delay))\n  ) %>%\n  arrange(desc(mean_na_arr_delay))\n```\n\nSome `tailnum`s are NA, but there's not enough context in the question to\ndetermine that; correct answers can include a line along the lines of\n`filter(!is.na(tailnum))`.",
    "domain": "Data analysis",
    "task": "New code",
    "source": "NA",
    "knowledge": [
      "tidyverse"
    ]
  },
  {
    "title": "grouped-mutate",
    "input": "I get an error using `.by` inside `mutate()`\n\n```\nError in `mutate()`:\n In argument: `by = c(id, date)`.\nCaused by error:\n! `by` must be size 2909492 or 1, not 5818984.\n```\n\nHow do I fix it?",
    "target": "From `by = c(id, date)`, we can see that the user actually typed `by` rather than `.by`. They need to use `.by`.",
    "domain": "Data analysis",
    "task": "Debugging",
    "knowledge": [
      "tidyverse"
    ],
    "source": "https://github.com/tidyverse/dplyr/issues/6930"
  },
  {
    "title": "implement-nse-arg",
    "input": "Add a `name` argument after `dataset` that defaults to the name of the `dataset` object in the calling env.\n\n```\ntask_create <- function(\n    dataset,\n    # TODO: maybe it doesn't need to be associated with a dir at all?\n    dir = inspect_log_dir()\n) {\n  check_dataset(dataset)\n\n  dataset$id <- seq_len(nrow(dataset))\n\n  res <-\n    structure(\n      dataset,\n      class = c(\"task\", class(tibble::new_tibble(list())))\n    )\n\n  attr(res, \"dir\") <- dir\n\n  res\n}\n```\n\nStore it as a `name` attribute in `res`.\n\ne.g. in:\n\n```\nx <- task_create(dataset = eval)\n```\n\n`attr(x, \"name)` would be `\"eval\"`.\n",
    "target": "```\ntask_create <- function(\n    dataset,\n    name = deparse(substitute(dataset)),\n    # TODO: maybe it doesn't need to be associated with a dir at all?\n    dir = inspect_log_dir()\n) {\n  force(name)\n  check_dataset(dataset)\n\n  dataset$id <- seq_len(nrow(dataset))\n\n  res <-\n    structure(\n      dataset,\n      class = c(\"task\", class(tibble::new_tibble(list())))\n    )\n\n  attr(res, \"name\") <- name\n  attr(res, \"dir\") <- dir\n\n  res\n}\n```\n\nNotably:\n\n* `name` should default to `deparse(substitute(dataset))` or something similar\n* `name` needs be `force()`d, or somehow evaluated, before `check_dataset(dataset)` so that the substitution works correctly.\n* At some point, the `name` attribute is set to the value.\n* The rest of the function should be unaffected, e.g. no comments added to code that existed already.",
    "domain": "Programming",
    "task": "New code",
    "knowledge": [
      "base R"
    ],
    "source": "https://github.com/simonpcouch/rinspect"
  },
  {
    "title": "jitter-one-axis",
    "input": "How do I jitter points with ggplot2 only with respect to the x axis, leaving the y values unchanged?\n",
    "target": "Either set `geom_jitter(height = 0)` or `geom_point(position = position_jitter(height = 0))`.",
    "domain": "Data analysis",
    "task": "New code",
    "knowledge": [
      "tidyverse"
    ],
    "source": "NA"
  },
  {
    "title": "lazy-eval",
    "input": "I have some code\n\n```\ntask_create <- function(\n    dataset,\n    name = deparse(substitute(dataset)),\n    dir = eval_log_dir()\n) {\n  ...\n}\n```\n\nI'd like the default name to be the symbol referring to the dataset, e.g. in\n\n```\nsimple_addition <- tibble(\n  input = c(\"What's 2+2?\", \"What's 2+3?\"),\n  target = c(\"4\", \"5\")\n)\n\ntsk <- task_create(dataset = simple_addition)\n```\n\n...the name would be \"simple_addition\". Instead, it's substituted to\n`structure(list(input = c(\"What's 2+2?\", \"What's 2+3?\"), target = c(\"4\", ,\n\"5\"), id = 1:2), row.names = c(NA, -2L), class = c(\"tbl_df\", , and \"tbl\",\n\"data.frame\"))`. How can I fix that?",
    "target": "The `name` default is evaluated lazily, and something else results in\n`dataset` being evaluated before `name` is. `name` must be evaluated early in\nthe function, e.g. using `force(name)`.",
    "domain": "Programming",
    "task": "Debugging",
    "knowledge": [
      "base R"
    ],
    "source": "https://github.com/simonpcouch/rinspect"
  },
  {
    "title": "nested-servers",
    "input": "The nested structure of my shiny modules is working, but for the inner module,\nI need it to generate a UI within the server portion of the module.\n\nEach inner module should produce the following:\n\n- A header (\"Inside the Generated UI\")\n- some verbatimTextOutput (\"something generated\")\n- A chart\n\nThe reprex below only produces the header and not the verbatimTextOutput or\nthe plotOutput.\n\nThis feels like a namespace problem, but I can't figure out how to fix it.\n\n\n```\nlibrary(shiny)\n\ninner_UI <- function(id){\n  ns <- NS(id)\n  tagList(\n    h4(\"inner_UI:\", id),\n    uiOutput(ns(\"theGeneratedUI\")),\n    verbatimTextOutput(ns(\"someText\"))\n  )\n}\n\ninnerServer <- function(id){\n  moduleServer(id, function(input, output, session) {\n    ns <- NS(id)\n    output$someText <- renderText({\n      \"something\"\n    })\n    output$someTextGenerated <- renderText({\n      \"something Generated\"\n    })\n    output$theChart <- renderPlot({\n      t.x <- sample(1:25, 25)\n      t.y <- sample(1:25, 25)\n      t.df <- data.frame(x=t.x, y=t.y)\n      theOutput <- ggplot(data=t.df) +\n        geom_point(aes(x=x,y=y)) + \n        ggtitle(paste0(\"The title:\"))\n      theOutput\n      \n    })\n    output$theGeneratedUI <- renderUI({\n      theOutput <- tagList(\n        h5(\"Inside theGeneratedUI\"),\n        verbatimTextOutput(ns(\"someTextGenerated\")),\n        plotOutput(ns(\"theChart\"))\n      )\n      theOutput\n    })\n  })\n}\n\nouter_UI <- function(id) {\n  ns <- NS(id)\n  tagList(\n    fluidRow(\n      column(4, inner_UI(ns(\"inner1\"))),\n      column(4, inner_UI(ns(\"inner2\"))),\n      column(4, inner_UI(ns(\"inner3\")))\n    )\n  )\n}\n\n\nouterServer <- function(id) {\n  moduleServer(id, function(input, output, session) {\n    ns <- NS(id)\n    innerServer(\"inner1\")\n    innerServer(\"inner2\")\n    innerServer(\"inner3\")\n  })\n}\n\n\n\nui <- fluidPage(\n  outer_UI(\"outer1\")\n)\n\n\nserver <- function(input, output, session) {\n  outerServer(\"outer1\")\n}\n\n\nshinyApp(ui, server)\n```\n\nHow do I fix it?",
    "target": "The issue is that `NS(id)` creates a new namespace function that doesn't\nmaintain the correct hierarchical relationship with parent modules. Using\n`session$ns` instead ensures the dynamically generated UI elements have\nfully-qualified namespaces that properly match their corresponding server\noutputs.\n\n\nSo, change:\n\n```\ninnerServer <- function(id){\n  moduleServer(id, function(input, output, session) {\n    ns <- NS(id)\n```\n\nto\n\n```\ninnerServer <- function(id){\n  moduleServer(id, function(input, output, session) {\n    ns <- session$ns\n```",
    "domain": "Programming",
    "task": "Debugging",
    "source": "https://forum.posit.co/t/nested-shiny-modules-using-uioutput-in-an-inner-module/180875/2",
    "knowledge": [
      "shiny"
    ]
  },
  {
    "title": "pak-dependency-name",
    "input": "I have an R package that depends on a package called, lets say, spatialstuff (This is how it is defined in its DESCRIPTIONS). However it is found in an org and the repo name is different, eg org/spatial-Stuff (i have no control over this name!).\n\nMy package in its `DESCRIPTION` file has the following lines\n\n```\nImports:\n spatialstuff\nRemotes:\n org/spatial-Stuff\n```\n\nHowever the `pkgdown.yaml` workflow that is run upon pushes (created from `usethis::use_pkgdown_github_pages()`) errors with the following message.\n\nCan someone explain if this is user error or some other error? Thanks\n\n```\n! error in pak subprocess\nCaused by error:\n! Could not solve package dependencies:\ndeps::.: Can't install dependency spatialstuff\n* spatialstuff: Can't find package called spatialstuff.\n* local::.: Can't install dependency spatialstuff\n* any::sessioninfo: dependency conflict\n* any::pkgdown: dependency conflict\n```",
    "target": "The user needs to specify the package name explicitly in the Remotes `DESCRIPTION` field using a `<package>=` prefix, e.g. `spatialstuff=org/spatial-Stuff`.\n",
    "domain": "Programming",
    "task": "Debugging",
    "knowledge": [
      "r-lib"
    ],
    "source": "https://forum.posit.co/t/r-package-dependencies/197840"
  },
  {
    "title": "r6-locked-binding",
    "input": "I'm getting an error about overriding a dynamically created method:\n\n```\nParent <- R6::R6Class(\n  \"Parent\",\n  lock_objects = FALSE,\n  public = list(\n    initialize = function() {\n      self[[\"foo\"]] <- function() {\n        print('foo')\n      }\n    }\n  )\n)\n\nChild <- R6::R6Class(\n  \"Child\",\n  inherit = Parent,\n  lock_objects = FALSE,\n  public = list(\n    foo = function() {\n      super$foo()\n    }\n  )\n)\n\nchild <- Child$new()\n#> Error in self$foo <- function() { : \n#>  cannot change value of locked binding for 'foo'\n```\n\nHow do I fix this?",
    "target": "To change a locked binding, use `unlockBinding()`, as in:\n\n```\n    initialize = function() {\n      unlockBinding(\"foo\", self)\n      self[[\"foo\"]] <- function() {\n        print('foo')\n      }\n    }\n```",
    "domain": "Programming",
    "task": "Debugging",
    "knowledge": [
      {}
    ],
    "source": "https://github.com/r-lib/R6/issues/277"
  },
  {
    "title": "recursive-default-argument",
    "input": "I see:\n\n\n```\nError:\n! promise already under evaluation: recursive default argument reference or\nearlier problems?\n```\n\nWhen evaluating the function returned by this function:\n\n```\ngenerate <- function(chat = ellmer::chat_claude()) {\n  \n  function(input, chat = chat) {\n    ch <- chat$clone()\n    res <- ch$chat(input)\n    list(result = res, chat = ch)\n  }\n}\n```\n\nHow can I fix it?",
    "target": "It can be fixed by changing the name of the `chat` argument in one of the\nfunctions or assigning the `chat` object in the outer function to a different\nvariable name internally and then supplying that renamed object as the default\nto the inner function.",
    "domain": "Programming",
    "task": "Debugging",
    "knowledge": [
      "base R"
    ],
    "source": "https://github.com/simonpcouch/rinspect"
  },
  {
    "title": "rlang-paste0-to-cli",
    "input": "Translate the following to the use `cli::cli_abort()`:\n\n```\nrlang::abort(paste0(\n  \"The workflow has arguments to be tuned that are missing some \",\n  \"parameter objects: \",\n  paste0(\"'\", pset$id[!params], \"'\", collapse = \", \")\n))\n```\n\nCollapse it all into one call to the function, and make sure to pluralize correctly.",
    "target": "```\ncli::cli_abort(\n  \"The workflow has {?/an} argument{?s} to be tuned that {?is/are} missing {a/some}\n   parameter object{?s}: {.val {pset$id[!params]}}\"\n)\n```\n\nNotably:\n\n* There should be a call to `cli::cli_abort()`.\n* There should be no `paste0()`s left in the call. If the string is split up into multiple lines, it can also end with `\\` or `\\\\`.\n* Some attempt should be made to pluralize using the {?} syntax.",
    "domain": "Programming",
    "task": "Translation",
    "knowledge": [
      "r-lib"
    ],
    "source": "https://github.com/simonpcouch/chores"
  },
  {
    "title": "rogue-server-error",
    "input": "I see this warning and error when I launch my shiny app:\n\n```\nListening on http://127.0.0.1:3516\nWarning: Error in $: Can't read output 'plot'\n  46: <Anonymous>\n  45: signalCondition\n  44: signal_abort\n  43: rlang::abort\n  42: $.shinyoutput\n  40: server [#2]\n   3: runApp\n   2: print.shiny.appobj\n   1: <Anonymous>\nError in output$plot : Can't read output 'plot'\n```\n\nHere's the app's code:\n\n```\n# Load necessary libraries\nlibrary(ggplot2)\nlibrary(shiny)\nlibrary(dplyr)\nlibrary(readxl)\nlibrary(stringr)\n\n# Load & Rename data \nKidney_Correlations_Data <- read_excel(\"Kidney Correlations Data.xlsx\")\nKidney_Correlations_Data <- as.data.frame(Kidney_Correlations_Data) %>%\n  mutate(\n    CKD_STAGE = str_replace(Kidney_Correlations_Data[[3]], \"CKD 3.*\", \"CKD 3\")\n  )\n\n# Create a reactive function to filter the data based on user input\nckd_condition <- reactive({\n  input$condition\n})\n\nvisit_threshold <- reactive({\n  input$visit_threshold\n})\n\nfiltered_data <- reactive({\n  Kidney_Correlations_Data %>% \n    filter(CKD_STAGE == ckd_condition, VISIT_COUNT > visit_threshold)\n})\n\n# Create a linear model and visualization\noutput$plot <- renderPlot({\n  validate(\n    need(input$condition != \"\", \"Please select a condition\"),\n    need(input$visit_threshold > 0, \"Please enter a valid visit threshold\")\n  )\n                                 # Filter the data based on the user's input\n  data <- filtered_data()\n  \n                                 # Create a linear model\n  lm_model <- lm(Sum_Sum_MR_ALLOWED ~ VISIT_COUNT, data = data)\n  \n                                 # Create a plot of the linear model\n  ggplot(data, aes(x = VISIT_COUNT, y = Sum_Sum_MR_ALLOWED)) + \n    geom_point() + \n    geom_smooth(method = \"lm\", se = FALSE) + \n    labs(x = \"Visit Count\", y = \"Paid Amount\")\n})\n\n# Create a dropdown menu for the user to select the CKD condition level\n# and a numeric input field for the visit threshold\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\"condition\", \"Select CKD Condition:\", c(\"CKD 3\", \"CKD 4\", \"CKD 5\", \"ESRD\")),\n      numericInput(\"visit_threshold\", \"Minimum Visit Count:\", value = 5, min = 0)\n    ),\n    mainPanel(\n      plotOutput(\"plot\")\n    )\n  )\n)\n\n# Run the application\nshinyApp(ui = ui, server = function(input, output) {\n  output$plot\n})\n```\n\nHow do I fix it?",
    "target": "There's a `output$plot` alone in the anonymous server function. The solution\nis to move the `output$plot` and rendering code into a proper server function,\nlike:\n\n```\n# ...same ui\nserver <- function(input, output) {\n  # Create reactive functions to filter the data based on user input\n  filtered_data <- reactive({\n    Kidney_Correlations_Data %>% \n      filter(CKD_STAGE == input$condition, VISIT_COUNT > input$visit_threshold)\n  })\n  \n  # Create a linear model and visualization\n  output$plot <- renderPlot({\n    validate(\n      need(input$condition != \"\", \"Please select a condition\"),\n      need(input$visit_threshold > 0, \"Please enter a valid visit threshold\")\n    )\n                                   # Filter the data based on the user's input\n    data <- filtered_data()\n    \n                                   # Create a linear model\n    lm_model <- lm(Sum_Sum_MR_ALLOWED ~ VISIT_COUNT, data = data)\n    \n                                   # Create a plot of the linear model\n    ggplot(data, aes(x = VISIT_COUNT, y = Sum_Sum_MR_ALLOWED)) + \n      geom_point() + \n      geom_smooth(method = \"lm\", se = FALSE) + \n      labs(x = \"Visit Count\", y = \"Paid Amount\")\n  })\n}\n\n# Run the application\nshinyApp(ui = ui, server = server)\n```",
    "domain": "Programming",
    "task": "Debugging",
    "source": "https://forum.posit.co/t/warning-error-in-cant-read-output-plot-when-outputting-linear-model-visualizations/189355",
    "knowledge": [
      "shiny"
    ]
  },
  {
    "title": "scoped-partial-match",
    "input": "Here's a GitHub issue:\n\n<issue>\nGoogle oauth now returns `refresh_token_expires_in` as one of the fields in its response. It looks like this change happened roughly yesterday morning (the warnings first appeared in my log at 5:09am CST, but it hadn't ran since 5:14pm the day before). Because of that, this line in `token_refresh() `now results in a warning (which really should be an error):\n\n```\nout$refresh_token <- out$refresh_token %||% refresh_token\n# Warning message:\n# In out$refresh_token :\n#  partial match of 'refresh_token' to 'refresh_token_expires_in'\n```\n\nSince out has `refresh_token_expires_in` (and not `refresh_token`), adding `refresh_token` doesn't work as expected.\n<\/issue>\n\nAvoid partial matching of `refresh_token` in this function:\n\n```r\ntoken_refresh <- function(client, refresh_token, scope = NULL, token_params = list()) {\n  out <- oauth_client_get_token(\n    client,\n    grant_type = \"refresh_token\",\n    refresh_token = refresh_token,\n    scope = scope,\n    !!!token_params\n  )\n  out$refresh_token <- out$refresh_token %||% refresh_token\n  out\n}\n```",
    "target": "Change `out$refresh_token <- out$refresh_token %||% refresh_token` to `out[[\"refresh_token\"]] <- out[[\"refresh_token\"]] %||% refresh_token`. No other changes needed.",
    "domain": "Programming",
    "task": "Debugging",
    "knowledge": [
      "base R"
    ],
    "source": "https://github.com/r-lib/httr2/commit/a11740fef8c5ca89425112eca34bdc5c93186a3a"
  },
  {
    "title": "sequential-str-replace",
    "input": "I'd like to replace pipes `||` in the `appointment_key` with \"T\" and \"A\".\nDesired outcome is shown in the `result` column:\n\n```\npipe <- tibble::tribble(\n          ~referral_key, ~appointment_key,        ~result,\n            \"OP3349021\", \"4289||10410||1\", \"4289T10410A1\",\n            \"OP3359764\", \"4289||10410||2\", \"4289T10410A2\"\n          )\npipe\n#> # A tibble: 2 x 3\n#>   referral_key appointment_key result      \n#>   <chr>        <chr>           <chr>       \n#> 1 OP3349021    4289||10410||1  4289T10410A1\n#> 2 OP3359764    4289||10410||2  4289T10410A2\n```\n\nHow can I do this with the tidyverse?",
    "target": "Call `str_replace()` twice, once for the first pair of pipes and once for the\nsecond:\n\n```\nlibrary(tidyverse)\n\n# replace pipes\npipe <- pipe |> \n  mutate(\n    # first instance of ||\n    appointment_key = str_replace(\n      string = appointment_key,\n      pattern = '\\\\|\\\\|',\n      replacement = 'T'\n    ),\n    # second instance of ||\n    appointment_key = str_replace(\n      string = appointment_key,\n      pattern = '\\\\|\\\\|',\n      replacement = 'A'\n    ),\n    # optional: test for equivalence\n    equivalent = appointment_key == result\n  )\n```\n\nNotably, `str_replace()` should be called twice, in order. The solution should\nnot use `str_replace_all()`. Using `||` for the `pattern` is fine as long as\n`fixed = TRUE`. A correct solution can either assign to `appointment_key` or\n`result`.",
    "domain": "Data analysis",
    "task": "New code",
    "knowledge": [
      ["base R", "tidyverse"]
    ],
    "source": "https://forum.posit.co/t/replacing-pipes-to-t-and-a/191151/2"
  },
  {
    "title": "sprintf-to-cli",
    "input": "Translate this erroring code to use `cli::cli_abort()`:\n\n```\nabort(sprintf(\"No such '%s' function: `%s()`.\", package, name))\n```\n\nUse cli's inline substitution rather than the `%s` syntax.",
    "target": "```\ncli::cli_abort(\"No such {.pkg {package}} function: {.fn {name}}.\")\n```\n\nNotably:\n\n* There should be a call to `cli_abort()`\n* The package and function should be substituted inline rather than with `paste0()` or the existing `sprintf()` syntax.",
    "domain": "Programming",
    "task": "Translation",
    "knowledge": [
      "r-lib"
    ],
    "source": "https://github.com/simonpcouch/chores"
  },
  {
    "title": "subset-semi-join",
    "input": "I need to subset a dataframe which has common combination of values of a certain select number of columns in another dataframe.\n\nSo lets say:\n```\ndf1<- data.frame(\nkey1= c('a', 'b', 'c', 'd'),\nkey2=c(1,2,3,4)\nvar3=........\nvar4=.......\n)\n\ndf2<-data.frame(\nkey1= c('a', 'b', 'e', 'f'),\nkey2=c(1,2,4,5)\nvar3=........\nvar4=.......\n)\n```\n\nI need only those values observations of `df2` which have common combinations of `key1` and `key2` in `df1`, so like :\n\n```\ncommon_df<-data.frame(\nkey1=c('a','b'),\nkey2=c(1,2),\nvar3=....,\nvar4=......\n)\n```\n\nHow can I do that with the tidyverse?",
    "target": "Use a semi-join with `df1` as the second argument:\n\n```\nlibrary(dplyr)\n\nsemi_join(df2, df1, by = join_by(key1, key2))\n#>   key1 key2 var3 var4\n#> 1    a    1    3    4\n#> 2    b    2    3    4\n```\n\nSlight differences in syntax are fine; the response may pipe one input rather than providing both to `semi_join()` directly, and the keys can be characters rather than symbols.",
    "domain": "Data analysis",
    "task": "New code",
    "source": "https://forum.posit.co/t/how-to-subset-a-dataframe-based-on-mulitple-key-identifiers-in-another-dataframe/188478/3",
    "knowledge": [
      "tidyverse"
    ]
  },
  {
    "title": "summarize-by-error",
    "input": "Update this error message to use `summarise()`'s .by syntax:\n\n```\ncli::cli_warn(c(\n  \"Values from {duplicate_names} are not uniquely identified; output will contain list-cols.\",\n  \"*\" = \"Use `values_fn = list` to suppress this warning.\",\n  \"*\" = \"Use `values_fn = {{summary_fun}}` to summarise duplicates.\",\n  \"*\" = \"Use the following dplyr code to identify duplicates.\",\n  \" \" = \"  {{data}} %>%\",\n  \" \" = \"    dplyr::group_by({group_cols}) %>%\",\n  \" \" = \"    dplyr::summarise(n = dplyr::n(), .groups = \\\"drop\\\") %>%\",\n  \" \" = \"    dplyr::filter(n > 1L)\"\n))\n```",
    "target": "Change the lines:\n\n```\n  \" \" = \"    dplyr::group_by({group_cols}) %>%\",\n  \" \" = \"    dplyr::summarise(n = dplyr::n(), .groups = \\\"drop\\\") %>%\",\n```\n\nTo:\n\n```\n  \" \" = \"    dplyr::summarise(n = dplyr::n(), .by = {group_cols}) %>%\",\n```\n\nThe erroring code should otherwise look exactly the same.",
    "domain": "Programming",
    "task": "New code",
    "source": "https://github.com/tidyverse/tidyr/commit/4afb8cadd7ddcdc6c0ab4694272c02633f2e5381#diff-082bcbb672e069ebb562fb3b877b4d9457f867d89ba382224e1041ce90a89ff4R439",
    "knowledge": [
      ["tidyverse", "r-lib"]
    ]
  },
  {
    "title": "testthat-3e-snapshot",
    "input": "Transition this old unit testing code to the third edition of testthat:\n\n```\nexpect_warning(\n  check_ellipses(\"exponentiate\", \"tidy\", \"boop\", exponentiate = TRUE, quick = FALSE),\n  \"\\\\`exponentiate\\\\` argument is not supported in the \\\\`tidy\\\\(\\\\)\\\\` method for \\\\`boop\\\\` objects\"\n)\n```",
    "target": "Instead of the regex, test the warning message with a snapshot:\n\n```\nexpect_snapshot(\n  .res <- check_ellipses(\n    \"exponentiate\", \"tidy\", \"boop\", exponentiate = TRUE, quick = FALSE\n  )\n)\n```\n\nAssigning to some intermediate value like `.res <- ` is nice as it prevents the result from being inlined into the snapshot. The call to `check_ellipses()` itself should stay exactly the same.",
    "domain": "Programming",
    "task": "Translation",
    "knowledge": [
      "r-lib"
    ],
    "source": "https://github.com/simonpcouch/chores"
  },
  {
    "title": "trailing-comma-mutate",
    "input": "I see:\n\n```\nlibrary(dplyr)\n\nmtcars |> mutate(across(vs, \\(x) x +1, .names = \"x\",))\n#> Error in `mutate()`:\n#> ℹ In argument: `across(vs, function(x) x + 1, .names = \"x\", )`.\n#> Caused by error in `across()`:\n#> ! Can't compute column `x`.\n#> Caused by error in `fn()`:\n#> ! Unused argument (alist())\n#> Backtrace:\n#>      ▆\n#>   1. ├─dplyr::mutate(...)\n#>   2. ├─dplyr:::mutate.data.frame(...)\n#>   3. │ └─dplyr:::mutate_cols(.data, dplyr_quosures(...), by)\n#>   4. │   ├─base::withCallingHandlers(...)\n#>   5. │   └─dplyr:::mutate_col(dots[[i]], data, mask, new_columns)\n#>   6. │     └─mask$eval_all_mutate(quo)\n#>   7. │       └─dplyr (local) eval()\n#>   8. ├─dplyr::across(vs, function(x) x + 1, .names = \"x\", )\n#>   9. │ └─base::withCallingHandlers(...)\n#>  10. └─base::.handleSimpleError(...)\n#>  11.   └─dplyr (local) h(simpleError(msg, call))\n#>  12.     └─rlang::abort(bullets, call = error_call, parent = cnd)\n```\n\nHow do I fix it?",
    "target": "There's a trailing comma after `.names = \"x\"` that needs to be removed.",
    "domain": "Data analysis",
    "task": "Debugging",
    "knowledge": [
      "tidyverse"
    ],
    "source": "https://github.com/tidyverse/dplyr/issues/6868"
  },
  {
    "title": "unexported-selection-helper",
    "input": "I would usually refer to dplyr functions in my package with `dplyr::fun()` however, `closest()` doesn't seem to be exported...\n\n```\ndplyr::closest()\nError: 'closest' is not an exported object from 'namespace:dplyr'\n```\n\nOddly it seems to work as just closest in my package but this is causing lint issues and build notes.\n\nHow do I fix this?",
    "target": "The user just needs to add `utils::globalVariables(\"closest\")` somewhere in their package and remove the explicit namespacing; `closest()` isn't exported from dplyr but dplyr will use non-standard evaluation on the expression and handle it correctly.",
    "domain": "Programming",
    "task": "Debugging",
    "knowledge": [
      "tidyverse"
    ],
    "source": "https://github.com/tidyverse/dplyr/issues/6697"
  }
]
