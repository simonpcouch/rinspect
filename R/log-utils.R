eval_log_new <- function(
    eval = eval_log_eval(),
    plan = eval_log_plan(),
    results = eval_log_results(),
    stats = eval_log_stats(),
    samples
) {
  res <-
    list(
      version = 2L,
      status = "success",
      eval = eval,
      plan = plan,
      results = results,
      stats = stats,
      samples = samples
    )

  structure(res, class = c("eval_log", class(res)))
}

# top-level entries ------------------------------------------------------------
eval_log_eval <- function(
    run_id,
    created = eval_log_timestamp(),
    task,
    task_id,
    task_version = 0,
    task_file = active_file(),
    task_attribs = c(),
    task_args = c(),
    dataset,
    model,
    model_args = c(),
    config = c(),
    # TODO: look into what this actually does
    revision = list(
      type = "git",
      origin = "https://github.com/UKGovernmentBEIS/inspect_ai.git",
      commit = "9140d8a2"
    ),
    packages = list(inspect_ai = "0.3.63"),
    scorers
) {
  list(
    run_id = run_id,
    created = created,
    task = task,
    task_id = task_id,
    task_version = task_version,
    task_file = task_file,
    task_attribs = task_attribs,
    task_args = task_args,
    dataset = dataset,
    model = model,
    model_args = model_args,
    config = config,
    revision = revision,
    packages = packages,
    scorers = scorers
  )
}

eval_log_plan <- function(
    name = "plan",
    steps = eval_log_plan_steps(),
    config = c()
) {
  list(
    name = name,
    steps = steps,
    config = config
  )
}

eval_log_results <- function(
    total_samples,
    completed_samples,
    scores
) {
  list(
    total_samples = total_samples,
    completed_samples = completed_samples,
    scores = scores
  )
}

eval_log_plan_steps <- function(name, arguments) {
  list(list(
    solver = name,
    params = arguments
  ))
}

eval_log_stats <- function(
    started_at,
    completed_at,
    model_usage
) {
  list(
    started_at = started_at,
    completed_at = completed_at,
    model_usage = model_usage
  )
}

eval_log_samples <- function(dataset, scores) {
  res <- list()
  for (i in seq_len(nrow(dataset))) {
    sample <- dataset[i, , drop = FALSE]
    res[[i]] <- eval_log_sample(sample, scores = scores)
  }
  res
}

eval_log_sample <- function(sample, scores) {
  chat <- sample$solver_chat[[1]]
  scorer_name <- scores$name

  turns <- chat$get_turns()
  list(
    id = sample$id,
    epoch = if ("epoch" %in% colnames(sample)) sample$epoch else {1},
    input = sample$input,
    target = sample$target,
    messages = translate_to_messages(chat),
    output = translate_to_output(chat),
    scores = dots_list(
      !!scorer_name := eval_log_score(
        output = sample$result[[1]],
        score = sample$score[[1]],
        scorer = scorer_name,
        scorer_chat = if ("scorer_chat" %in% names(sample)) {
          sample$scorer_chat[[1]]
        } else {
          NULL
        }
      )
    ),
    metadata = c(),
    store = c(),
    events = translate_to_events(sample = sample),
    model_usage = sum_model_usage(list(chat)),
    # TODO: these seem to be prompts passed to the judges
    attachments = c()
  )
} 

# sub-level entries ------------------------------------------------------------
eval_log_metrics <- function(
    name = character(),
    value = numeric(),
    options = list()
) {
  list(
    name = name,
    value = value,
    options = options
  )
}

eval_log_score <- function(output, score, scorer, scorer_chat = NULL) {
  if (is.null(scorer_chat)) {
    return(list(
      value = score,
      answer = output,
      explanation = paste0("Detected correct answer."),
      metadata = c()
    ))
  }

  turns <- scorer_chat$get_turns()
  explanation <- scorer_chat$last_turn()@text
  
  list(
    value = score,
    answer = output,
    explanation = explanation,
    metadata = list(
      grading = lapply(turns, eval_log_metadata_grading)
    )
  )
}

# Inspect formats the content a bit differently depending
# on whether the turn role is user vs. assistant.
eval_log_metadata_grading <- function(turn) {
  if (turn@role == "user") {
    return(
      list(
        id = generate_id(),
        content = turn@text,
        role = "user"
      )
    )
  }

  list(
    id = generate_id(),
    content = list(list(type = "text", text = turn@text)),
    source = "generate", 
    role = turn@role
  )
}

eval_log_eval_scorers <- function(name) {
  list(list(
    name = name,
    options = c(),
    # TODO: make this dynamic once implemented
    metrics = list(
      list(name = "mean", options = c())
    ),
    metadata = c()
  ))
}

eval_log_timestamp <- function(time = Sys.time()) {
  timestamp <- format(time, "%Y-%m-%dT%H:%M:%S%z")
  gsub("([+-][0-9]{2})([0-9]{2})$", "\\1:\\2", timestamp)
}

generate_id <- function(length = 22) {
  chars <- c(letters, LETTERS, 0:9)
  paste0(sample(chars, length, replace = TRUE), collapse = "")
}

eval_log_filename <- function(eval_log) {
  paste0(
    gsub(":", "-", eval_log$eval$created), "_",
    gsub(" ", "-", gsub("_", "-", eval_log$eval$task)), "_",
    eval_log$eval$task_id, ".json"
  )
}

# given the list of solvers in a dataset, sum across all of their token usage
# TODO: this doesn't work for non-Claude?
sum_model_usage <- function(solvers) {
  chat <- solvers[[1]]
  
  usage_per_solver <- lapply(
    solvers,
    function(chat) {translate_to_model_usage(chat)[[1]]}
  )
  res <- Reduce(function(x, y) Map(`+`, x, y), usage_per_solver)

  # TODO: ultimately, this needs to be per-model
  dots_list(!!chat$get_model() := res)
}

active_file <- function() {
  if (!rstudioapi::isAvailable()) {
    return("")
  }
  
  active_document <- rstudioapi::getActiveDocumentContext()
  active_document$path
}

results_scores <- function(name, metrics) {
  list(list(
    name = name,
    scorer = name,
    params = structure(list(), names = character(0)),
    metrics = metrics
  ))
}
